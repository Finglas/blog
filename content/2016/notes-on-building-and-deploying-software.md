Title: Notes on Building and Deploying Software
Date: 2016-07-10 15:18
Author: Shaun Finglas
Tags: http://schemas.google.com/blogger/2008/kind#post, notes, build, deployment
Slug: notes-on-building-and-deploying-software

#### Builds and Deploys

Ideally a build and deploy should be a single step, included within the
check out of the repository. Additionally the build should include and
install pre-requisites if missing. You can safely assume the target OS
is at least configured, but any missing packages should be installed as
needed.

The core steps regardless of platform or technology follow a common
pattern. A number of these steps can be performed asynchronously. For
example, it is possible to run a suite of tests in parallel, rather than
individually. This can save massive amounts of time. As a first approach
perform all steps synchronously, only adjusting once stable.

<ul>
<li>
Compile/Lint - *Sync*

</li>
<li>
Run Unit Tests - *Async*

</li>
<li>
Deploy - *Async*

</li>
-   Warm up (cache hits, web server)
-   Data (run migrations)
-   Configuration
-   Host Environment

<li>
Run Integration/Acceptance Tests - *Async*

</li>
</ul>
This whole process should be executed regardless of environment. A local
developer machine only differs to production in terms of topology. If
you cannot execute the exact same process that you are performing upon
commit, you can never be sure the commit will work. CI tooling should
act as nothing more than an aggregation of stats and artefacts that are
generated by invoking the build/deploy script.

#### Components

A working software application can be decomposed into four components.

-   Executable code - your application.
-   Configuration - connection strings or credentials.
-   Host environment - target deployment machine.
-   Data - required data for use, or persistent stores such as
    databases.

If any of these change, trigger the feedback process as they can all
change the behaviour of the application.

#### Automation

-   Aim to automate everything, but do it gradually over time. Aim for
    the bottlenecks to begin with if the task of automating the
    deployment pipeline is daunting.
-   Keep everything in source control. Never allow your CI tool to
    control your pipeline.
-   Don't check passwords or credentials into source control.

#### Speed is Key

-   Too long and people wont commit often.
-   Under thirty seconds is ideal. Faster is better.
-   Fail the build if the time exceeds a set threshold. You can use
    [ratcheting](http://blog.shaunfinglas.co.uk/2014/11/ratcheting.html)
    to reduce this over time.
-   Monitor tests regularly and try to speed the slowest ones up.

#### Build and Deploy Etiquette

-   Don't check in on a broken build, unless you are fixing it.
-   Perform an update prior to commit and run the whole build/deploy
    process.
-   Never go home on a broken build, and ideally don't check in just
    before leaving.
-   Never deploy on Friday's or whenever there will be few developers
    around on hand, such as holiday periods.
-   Always be ready to revert to the previous version. If the fix takes
    longer than just simply reverting the changes, don't try and fix the
    build. Just revert.
-   Fail the build for architectural breaches such as a module
    referencing a module it shouldn't.
-   [Fail the build for
    warnings](http://blog.shaunfinglas.co.uk/2014/02/warnings-as-errors.html)
    or code style breaches. Warnings can hide serious problems.

#### Infrastructure

-   Lock down production environments.
-   Treat test environments equally, these should also be locked down
    from manual changes.
-   If you cannot create your infrastructure from scratch via an
    automated process to begin with, implement access control so that
    any changes must be requested and logged.
-   Any changes should be back filled and tested. Use some form of audit
    or access control to manage these steps.

#### Data

-   Use migrations to manage data. Have a version table that stores the
    schema version. Use migrations to roll forwards or roll back
    incrementally.
-   Each migration should have an "up" and a "down" step. For example,
    up adds a table, down removes it. Run these both before committing
    to make sure they work.
-   Migrations allow you to decouple the deployment of your application
    from the deployment of your database.
-   The use of views or stored procedures can add a layer of abstraction
    between applications and databases. This allows changes to the
    underlying DB to have a smaller, limited effect.

</p>

